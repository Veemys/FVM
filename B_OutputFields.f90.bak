subroutine output_fields(io, NI, NJ, x, y, p, grad, graderror, v, div, diverror, rot, roterror, laplacian, laplacianerror)
implicit none

integer 							:: io, NI, NJ
real(8), dimension(NI, NJ) 			:: x, y
real(8), dimension(0:NI, 0:NJ) 		:: p, div, diverror, rot, roterror, laplacian, laplacianerror
real(8), dimension(0:NI, 0:NJ, 2) 	:: grad, graderror, v

write(io, *) 'VARIABLES = "X", "Y", "P", "Vx", "Vy", "GradPx", "GradPy", "DivV", "RotV", "LaplacianP", &
						  "DivV_err", "RotV_err", "LapP_error", "GradPx_err", "GradPy_err"'
write(io, *) 'ZONE I=', NI, ', J=', NJ, ', DATAPACKING=BLOCK, VARLOCATION=([3-20]=CELLCENTERED)'
write(io, '(100F14.7)') x(1:NI, 1:NJ) 
write(io, '(100F14.7)') y(1:NI, 1:NJ)
write(io, '(100F14.7)') p(1:NI-1, 1:NJ-1)
write(io, '(100F14.7)') v(1:NI-1, 1:NJ-1, 1)
write(io, '(100F14.7)') v(1:NI-1, 1:NJ-1, 2)
write(io, '(100F25.17)') grad(1:NI-1, 1:NJ-1, 1)
write(io, '(100F25.17)') grad(1:NI-1, 1:NJ-1, 2)
write(io, '(100F25.17)') div(1:NI-1, 1:NJ-1)
write(io, '(100F25.17)') rot(1:NI-1, 1:NJ-1)
write(io, '(100F25.17)') laplacian(1:NI-1, 1:NJ-1)
write(io, '(100F25.17)') diverror(1:NI-1, 1:NJ-1)
write(io, '(100F25.17)') roterror(1:NI-1, 1:NJ-1)
write(io, '(100F25.17)') laplacianerror(1:NI-1, 1:NJ-1)
write(io, '(100F25.17)') graderror(1:NI-1, 1:NJ-1, 1)
write(io, '(100F25.17)') graderror(1:NI-1, 1:NJ-1, 2)

end subroutine

! out temp field
subroutine output_temperature(io, ni, nj, x, y, t)
implicit none

integer								:: io, i, j, ni, nj
real(8), dimension(ni, nj) 			:: x, y
real(8), dimension(0:ni, 0:nj) 		:: t

write(io, *) 'VARIABLES = "X", "Y", "T"'
write(io, *) 'ZONE I=', ni, ', J=', nj, ', DATAPACKING=BLOCK, VARLOCATION=([3-20]=CELLCENTERED)'
write(io, '(100F14.7)') x(1:ni, 1:nj) 
write(io, '(100F14.7)') y(1:ni, 1:nj)
write(io, '(100F14.7)') t(1:ni-1, 1:nj-1)

end subroutine

PROGRAM OPENMP_PI_SPMD

INCLUDE 'omp_lib.h'
INTEGER I, N, NTHREADS, TID, ISTART, IEND
DOUBLE PRECISION T1, T2, X, STEP, INTEG, THREAD_SUM /0.0/
PARAMETER (N = 1000000000)

STEP = 1.0 / N

T1 = OMP_GET_WTIME()
!$OMP PARALLEL IF(N .GE. 100) PRIVATE(TID, X, I, ISTART, IEND) REDUCTION(+:THREAD_SUM)

TID = OMP_GET_THREAD_NUM()
IF (TID.EQ.0) NTHREADS = OMP_GET_NUM_THREADS()

ISTART = TID + 1
IEND = N
DO I=ISTART, IEND, NTHREADS
	X = (I - 0.5)*STEP
	THREAD_SUM = THREAD_SUM + 1.0 / (2.0 + sin(x))
END DO
!$OMP END PARALLEL
T2 = OMP_GET_WTIME()

PRINT*, 'Comp. time =', T2 - T1
INTEG = STEP * THREAD_SUM
PRINT *, 'INTEG = ', INTEG

END
